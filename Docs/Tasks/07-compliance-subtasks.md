# Sub-Tasks: Plan 07 - Compliance & Governance (EU-First)

---

## Task 7.1: Create Consent Management Tables & Models

### Sub-task 7.1.1: Create consent_records migration
- Columns per plan spec
- Index: `(environment_id, app_user_id, consent_type)`
- Index: `(created_at)` for audit retention

### Sub-task 7.1.2: Create ConsentRecord model
- HasUuids, relationships to Environment and AppUser
- Casts: consent_type → ConsentType enum, granted → boolean
- Scope: `active()` → granted=true AND revoked_at IS NULL

### Sub-task 7.1.3: Create ConsentService
- `grantConsent(Environment $env, AppUser $user, ConsentType $type, ?string $ip): ConsentRecord`
  - Create record, truncate IP address, audit log
- `revokeConsent(Environment $env, AppUser $user, ConsentType $type): void`
  - Set revoked_at, audit log
- `hasConsent(Environment $env, AppUser $user, ConsentType $type): bool`
  - Check for active consent record
- `getConsentStatus(Environment $env, AppUser $user): array`
  - Return all consent types with granted/revoked status

### Sub-task 7.1.4: Integrate consent check into ingestion pipeline
- In ProcessIngestBatch job, after resolving AppUser:
  - If environment has `consent_required = true`:
    - Check `ConsentService::hasConsent()` for Analytics type
    - If crash event: check CrashReporting consent
    - If trace event: check Performance consent
    - If no consent: reject event, increment rejected count

### Sub-task 7.1.5: Create consent API endpoint
- `POST /api/v1/ingest/consent` — SDK sends consent grants/revocations
- Uses same project_key auth middleware
- Payload: `{ "anonymous_id": "...", "consents": [{"type": "analytics", "granted": true}] }`

### Sub-task 7.1.6: Write consent tests
- Test grant creates record
- Test revoke updates record
- Test hasConsent returns correct status
- Test ingestion rejects events without consent when required
- Test ingestion allows events when consent granted

---

## Task 7.2: Create Audit Log System

### Sub-task 7.2.1: Create audit_logs migration
- Columns per plan spec, include all indexes

### Sub-task 7.2.2: Create AuditLog model
- HasUuids, jsonb cast for metadata
- No factory needed (auto-generated by system)

### Sub-task 7.2.3: Create AuditAction enum
- All mandatory actions: `DsarReceived`, `DataDeletionRequested`, `DataDeletionCompleted`, `DeletionCertificateGenerated`, `DataExportRequested`, `DataExportCompleted`, `DataExportDownloaded`, `ConsentGranted`, `ConsentRevoked`, `RetentionEnforcementRun`, `RetentionDataPurged`, `ProcessingRestrictionApplied`, `ProcessingRestrictionLifted`, `ProjectKeyCreated`, `ProjectKeyRevoked`, `EnvironmentSettingsChanged`, `PiiSettingsChanged`, `LawfulBasisChanged`, `DataBreachReported`

### Sub-task 7.2.4: Create AuditService
- Static `log()` method:
  ```php
  public static function log(AuditAction $action, ?Team $team, ?User $actor, ?string $resourceType = null, ?string $resourceId = null, array $metadata = []): AuditLog
  ```
- Auto-truncate IP address
- Never delete audit logs (retention enforcement skips this table)

### Sub-task 7.2.5: Create Auditable trait
- `logAudit(AuditAction $action, array $metadata = []`: convenience method
- Auto-resolve current user and team from auth context

### Sub-task 7.2.6: Apply audit logging to existing services
- ProjectKey creation/revocation
- Environment settings changes

### Sub-task 7.2.7: Write audit log tests
- Test log creates record with all fields
- Test IP truncation works
- Test metadata stored as JSON

---

## Task 7.3: Implement Data Deletion Workflow (GDPR Art. 17)

### Sub-task 7.3.1: Create DeletionService
- `requestDeletion(Environment $env, User $requestor, string $targetUserId, DeletionScope $scope): DataDeletionRequest`
  - Create request with `sla_deadline_at = now()->addDays(30)`
  - Audit log: DsarReceived
  - Dispatch ProcessDataDeletion job

### Sub-task 7.3.2: Create ProcessDataDeletion job
- Queue: `compliance`
- Load request, update status to processing

### Sub-task 7.3.3: Implement full erasure logic
- Find AppUser by anonymous_id or user_id in environment
- Delete all linked: events, crash_reports, traces, analytics_sessions
- Delete the AppUser record itself
- Preserve consent_records (Art. 7 accountability)
- Audit log each table deletion

### Sub-task 7.3.4: Implement pseudonymization logic
- Replace anonymous_id with irreversible hash
- Replace user_id with irreversible hash
- Null out device association if identifiable
- Keep event data for aggregate purposes
- Audit log

### Sub-task 7.3.5: Implement deletion certificate generation
- Generate JSON document:
  ```json
  {
    "certificate_id": "...",
    "deletion_type": "full_erasure",
    "target_user": "hashed_identifier",
    "environment": "prod",
    "data_categories_deleted": ["events", "sessions", "crash_reports", "traces", "user_profile"],
    "records_deleted": 1234,
    "completed_at": "...",
    "requested_at": "...",
    "gdpr_article": "Art. 17"
  }
  ```
- Store certificate path on deletion request

### Sub-task 7.3.6: Implement SLA tracking
- On request creation: set 30-day deadline
- Scheduled check: flag overdue requests
- Notify team admin when deadline approaches (7 days, 3 days, 1 day)

### Sub-task 7.3.7: Create deletion API endpoint
- `POST /api/v1/projects/{project}/compliance/erasure`
- Auth: Sanctum with `compliance:write` ability
- Payload: `{ "user_identifier": "...", "scope": "full_delete" }`

### Sub-task 7.3.8: Create deletion admin UI (Livewire)
- Form: user identifier input, scope selection, impact preview
- Confirmation modal
- Request list with SLA status indicators

### Sub-task 7.3.9: Write deletion tests
- Test full erasure removes all user data
- Test pseudonymization replaces identifiers
- Test consent records preserved after deletion
- Test deletion certificate generated correctly
- Test SLA deadline calculated and tracked
- Test overdue notification triggered

---

## Task 7.4: Implement Data Export Workflow (GDPR Art. 15, 20)

### Sub-task 7.4.1: Create ExportService
- `requestExport(Environment $env, User $requestor, string $targetUserId): DataExportJob`

### Sub-task 7.4.2: Create ProcessDataExport job
- Collect all user data categories
- Build structured JSON with metadata (categories, purposes, retention info)
- Create ZIP archive
- Store with temporary signed URL
- Notify admin

### Sub-task 7.4.3: Define export JSON schema
- Include: `data_subject`, `processing_purposes`, `retention_periods`, `data_categories`, `user_profile`, `events`, `sessions`, `crash_reports`, `traces`, `consent_records`

### Sub-task 7.4.4: Implement signed URL download
- Generate signed URL with 48-hour expiry using Laravel Storage
- Audit log on download

### Sub-task 7.4.5: Create export admin UI
- Request form, list with download links, SLA status

### Sub-task 7.4.6: Write export tests
- Test export contains all data categories
- Test signed URL expires correctly
- Test download triggers audit log

---

## Task 7.5-7.9: Remaining compliance tasks

### Sub-task 7.5.1-7.5.5: Retention enforcement (command, scheduler, batch delete, audit, notification)
### Sub-task 7.6.1-7.6.4: PII detector (patterns, UI, defaults, integration)
### Sub-task 7.7.1-7.7.4: Data breach (migration, model, UI with 72h tracker, template)
### Sub-task 7.8.1-7.8.5: Compliance dashboard (Livewire page, DSAR section, audit viewer, breach section, nav integration)
### Sub-task 7.9.1-7.9.12: All compliance tests (one per test case in Task 7.9)
